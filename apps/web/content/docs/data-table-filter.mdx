---
title: Data table filter
section: Components
summary: A powerful data table filter component. Library-agnostic. Supports client and server-side filtering.
badge: alpha
---

<div className='py-8 px-16 border border-border rounded-lg bg-white dark:bg-black'>
  <DataTableDemo />
</div>

## Introduction

This library is an add-on to your existing data table for filtering your data, providing key building blocks for building a powerful filtering experience:

- A React hook, `useDataTableFilters()`, which exposes your data table filters state.
- A `<DataTableFilter />` component, built with [shadcn/ui](https://ui.shadcn.com) and inspired by [Linear](https://linear.app/homepage)'s design.
- Integrations for key libraries, such as [TanStack Table](https://tanstack.com/table).

Some answers to the most common questions:

- **Can I use this with X library?** In theory, yes!
- **Can I use this with *client*-side filtering?** Yes!
- **Can I use this with *server*-side filtering?** Yes!

## Installation

From the command line, install the component into your project:

```bash
npx shadcn@latest add https://ui.bazza.dev/r/filters
```

## Concepts

Let's take a look at the most important concepts for using this component.

### Column data types

Whenever you want to filter a column, you need to define what type of data it contains. `ColumnDataType` identifies the types of data we currently support filtering for.

Set the `type` property of the column meta (explained below) to one of the following values:

```ts
export type ColumnDataType =
  | 'text'         /* Text data */
  | 'number'       /* Numerical data */
  | 'date'         /* Dates */
  | 'option'       /* Single-valued option (e.g. status) */
  | 'multiOption'  /* Multi-valued option (e.g. labels) */
```

### Column options

For `option` and `multiOption` columns, we represent each possible option as a `ColumnOption`:

```ts
export interface ColumnOption {
  /* The label to display for the option. */
  label: string
  /* The internal value of the option. */
  value: string
  /* An optional icon to display next to the label. */
  icon?: React.ReactElement | React.ElementType
}
```

#### `label`

This is the label or display name for the option.

#### `value`

This is the interval value for the option and must be unique across all options for a given column.

For an `option` column, the filter value is a `string` which matches the `value` property of chosen column option.

For a `multiOption` column, the filter value is a `string[]` where each array member is the `value` property of the chosen column option.

#### `icon`

Optionally, you can provide an icon to represent the column option.

An icon must be provided for every column option. Otherwise, icons will not be displayed for the column's options.

## Usage

### Add component

Import the `<DataTableFilter />` component and pass it your `table` instance:

```tsx {6}
import { DataTableFilter } from '@/components/data-table-filter'

export default function DataTable() {
  return (
    <div>
      <DataTableFilter table={table} />
      <div className="rounded-md border">
        <Table>
          {/* ... */}
        </Table>
      </div>
    </div>
  )
}
```

### Update columns

#### Updating your columns

For each column that you want to be filterable, you need to do two things:

- Use our provided `filterFn()` for filtering the column data.
- Add the `meta` property using the `defineMeta()` helper function.

For the filter function, we provide one for you - it is conveniently called `filterFn()` and takes a single argument `type` which is the column data type (i.e. `ColumnDataType`).

For the column meta, we provide a helper function called `defineMeta()` which takes two arguments: **(1)** the property name from your data object, and **(2)** an object containing the column meta.

When specifying the property name, you must use an accessor function, as demonstrated below.

```ts
export const columns = [
  columnHelper.accessor('status', {
    filterFn: filterFn('option'),
    meta: defineMeta(row => row.status, {
      displayName: 'Status',
      type: 'option',
      icon: CircleDotDashedIcon,
      options: ISSUE_STATUSES,
    }),
  }),
]
```

## Integrations

### `nuqs`

> [!WARNING] This integration is in alpha.
> We are working on making this easier to use.

You can use [`nuqs`](https://nuqs.47ng.com/) to persist the filter state in the URL.

1. Install the `nuqs` and `zod` packages:

```bash
npm install nuqs zod
```

2. Use the appropriate `nuqs` adapter for your framework from the [nuqs docs](https://nuqs.47ng.com/docs/adapters).

3. Create your Zod schema for the query filter state:

```ts
import { z } from 'zod'

const dataTableFilterQuerySchema = z
  .object({
    id: z.string(),
    value: z.object({
      operator: z.string(),
      values: z.any(),
    }),
  })
  .array()
  .min(0)

type DataTableFilterQuerySchema = z.infer<typeof dataTableFilterQuerySchema>
```

4. Create the following helper function:

```ts
function initializeFiltersFromQuery<TData, TValue>(
  filters: DataTableFilterQuerySchema,
  columns: ColumnDef<TData, TValue>[],
) {
  return filters && filters.length > 0
    ? filters.map((f) => {
        const columnMeta = columns.find((c) => c.id === f.id)!.meta!

        const values =
          columnMeta.type === 'date'
            ? f.value.values.map((v: string) => new Date(v))
            : f.value.values

        return {
          ...f,
          value: {
            operator: f.value.operator,
            values,
            columnMeta,
          },
        }
      })
    : []
}
```

5. Update your date table component file:

```tsx {1-2,4-8,10-11,18-25}
import { parseAsJson, useQueryState } from 'nuqs'
import { type ColumnDef } from '@tanstack/react-table'

export default function YourDataTableComponent() {
  const [queryFilters, setQueryFilters] = useQueryState(
    'filter',
    parseAsJson(dataTableFilterQuerySchema.parse).withDefault([]),
  )
  const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>(
    // Replace `Issue` with your data type
    () => initializeFiltersFromQuery(queryFilters, columns as ColumnDef<Issue>[]),
  )

  const table = useReactTable({
    /* ... */
  })

  React.useEffect(() => {
    setQueryFilters(
      columnFilters.map((f) => ({
        id: f.id,
        value: { ...(f.value as any), columnMeta: undefined },
      })),
    )
  }, [columnFilters, setQueryFilters])

  /* ... */
}
```

## Overview

Let's take a high-level look at how we've created the data table filter component.

This will help you understand what each file contains and the general component composition.

### File structure

The data table filter component is composed of several files.

Components are placed in the `@/components` directory - all components are placed in a single file for ease of distribution:

- `data-table-filter.tsx`: The main component file.

Types, interfaces, and utilities are placed in the `@/lib` directory:

- `array.ts`: Utility functions for working with arrays.
- `filters.ts`: All TypeScript types, interfaces, and constants related to the data table filter component. Also includes the filter functions `filterFn()` for each column type.
- `table.ts`: Utility functions for working with the TanStack Table library.

### Component structure

A `PropertyFilterItem` component is composed of the following parts:

- `PropertyFilterSubject` shows the name and _(optionally)_ icon of the property being filtered on.
- `PropertyFilterOperator` shows the operator used to filter on the property.
- `PropertyFilterValue` shows the actual filter value.

<ResponsiveImage
  lightSrc='/docs/data-table-filter/property-filter-item-composition-light.png'
  darkSrc='/docs/data-table-filter/property-filter-item-composition-dark.png'
  caption='The composition of a property filter item.'
/>

The `PropertyFilterOperator` and `PropertyFilterValue` components are represented by a `Controller` which is essentially a `Popover` with an associated trigger and content.

We can break down the `PropertyFilterValueController` as an example:

- `PropertyFilterValueDisplay` is the popover **trigger**. This displays the filter value for the associated property.
- `PropertyFilterValueMenu` is the popover **content**. This renders the menu for modifying the filter value.

<ResponsiveImage
  lightSrc='/docs/data-table-filter/property-filter-value-composition-light.png'
  darkSrc='/docs/data-table-filter/property-filter-value-composition-dark.png'
  caption='The composition of a property filter value controller.'
/>

The `PropertyFilterOperatorController` has a similar composition and can be inferred from the above description and image.

## Changelog

### 2025.04.12

We've squashed a pesky bug where inferred column options would show duplicate entries in the filter menu.

We've updated the implementation of `uniq()` to use deep equality checks, instead of the previous referencial equality checks via `new Set()`.

- Issue: https://github.com/kianbazza/ui/issues/49
- PR: https://github.com/kianbazza/ui/pull/51

### 2025.04.01

> [!DANGER] This is a breaking change.

This adds support for filtering columns where the column value is not strictly a property of the original data. This was not possible before, due to the limitation of `defineMeta`'s first argument, which only accepted a direct property on the initial data type.

You can now filter columns where the value is:

- a deeply nested property (i.e. `user.name`)
- accessed using a function (i.e. `row => row.user.name.split(' ')[0]`)

To accomplish this, we've decided to change the interface for the `defineMeta` helper function. The first property is now an **accessor function**, instead of an accessor key.

See the example below for how to migrate:

```ts
type Issue = {
  status: string
  user: {
    name: string
  }
}
```

```ts {15-22}
const columns = [
  /* ... */
  columnHelper.accessor('status', {
    meta: defineMeta(
      'status', // [!code --]
      row => row.status, // [!code ++]
      { 
        type: 'option',
        icon: CircleDotDashedIcon,
        options: ISSUE_STATUSES,
      }
    ),
  }),
  columnHelper.accessor(row => row.user.name, {
    meta: defineMeta(
      row => row.user.name,
      { 
        type: 'option',
        icon: AvatarIcon,
        /* ... */
      }
    ),
  }),
]
```
