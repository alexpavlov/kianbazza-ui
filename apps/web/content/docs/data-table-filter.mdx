---
title: Data table filter
section: Components
summary: A powerful data table filter component. Library-agnostic. Supports client and server-side filtering.
badge: alpha
---

<div className='py-8 px-16 border border-border rounded-lg bg-white dark:bg-black'>
  <DataTableDemo />
</div>

## Introduction

This library is an add-on to your existing data table for filtering your data, providing key building blocks for building a powerful filtering experience:

- A React hook, `useDataTableFilters()`, which exposes your data table filters state.
- A `<DataTableFilter />` component, built with [shadcn/ui](https://ui.shadcn.com) and inspired by [Linear](https://linear.app/homepage)'s design.
- Integrations for key libraries, such as [TanStack Table](https://tanstack.com/table) and [nuqs](https://nuqs.47ng.com/).

Some answers to the most common questions:

- **Can I use this with X library?** In theory, yes!
- **Can I use this with *client*-side filtering?** Yes!
- **Can I use this with *server*-side filtering?** Yes!

## Installation

From the command line, install the component into your project:

```bash
npx shadcn@latest add https://ui.bazza.dev/r/filters
```

## Quick Start

> [!WARNING] This section is under development.

### Blocks

> [!WARNING] This section is under development.

You can install pre-built blocks directly into your codebase.

These have been tested with Next.js, but should work with any React framework.

### Concepts

Let's take a look at the most important concepts for using this component.

#### Filters

The state of the applied filters on a table is represented as `FiltersState`, which is a `FilterModel[]`:

```ts
type FilterModel<TType extends ColumnDataType = any> = {
  columnId: string
  operator: FilterOperators[TType] // i.e. 'is', 'is not', 'is any of', etc.
  values: FilterValues<TType>
}
```

Each `FilterModel` represents a single filter for a specific column.

#### Column data types

When you want to make a column filterable, you first need to define what type of data it contains.

`ColumnDataType` identifies the types of data we currently support filtering for:

```ts
type ColumnDataType =
  | 'text'         /* Text data */
  | 'number'       /* Numerical data */
  | 'date'         /* Dates */
  | 'option'       /* Single-valued option (e.g. status) */
  | 'multiOption'  /* Multi-valued option (e.g. labels) */
```

#### Column options

For `option` and `multiOption` columns *(we'll refer to these as **option-based columns**)*, there exists a set of possible **options** for each column - we call these **column options**.

> For example, an issues table could have a `status` column with the options "Backlog", "To Do", "In Progress", and "Done".

{/* Option-based columns can get their options data from two sources:

- The table data itself; we infer the options from the available data.
- The column's `options` property. */}

We represent each option as a `ColumnOption`:

```ts
interface ColumnOption {
  /* The label to display for the option. */
  label: string
  /* The internal value of the option. */
  value: string
  /* An optional icon to display next to the label. */
  icon?: React.ReactElement | React.ElementType
}
```

### Column configuration

We describe each column in our data table as a `ColumnConfig`.

We create a `ColumnConfig` using a builder instance:

```ts
/* Create the configuration builder instance. */
const dtf = createColumnConfigHelper<Issue>()

/* Create the column configurations. */
export const columnsConfig = [
  dtf
    .text()
    .id('title')
    .accessor((row) => row.title)
    .displayName('Title')
    .icon(Heading1Icon)
    .build(),
  dtf
    .option()
    .accessor((row) => row.status.id)
    .id('status')
    .displayName('Status')
    .icon(CircleDotDashedIcon)
    .build(),
  /* ... */
] as const
```

#### Filters instance

We use the `useDataTableFilters()` hook to create our data table filters instance.

This hooks handles the logic for filtering the data (if using the `client` strategy) and updating the filters state.

```tsx
const { columns, filters, actions, strategy } = useDataTableFilters({
  strategy: 'client',       
  data: issues.data ?? [], 
  columnsConfig,          
})
```

Given those inputs, the hook creates your data table filters instance.

The instance has the following properties:

- `columns`: The `Column[]` for your data table filters. A `Column` is a superset of a `ColumnConfig`, with additional properties & methods.
- `filters`: The filters state, represented as a `FilterState` object.
- `actions`: A collection of mutators for the filters state.
- `strategy`: The strategy used for filtering (`client` or `server` side filtering).

#### Filters component

The visual component for the data table filter is the `<DataTableFilter />` component.

It takes the `columns`, `filters`, `actions` and `strategy` from the hook as input.

```tsx {6-11}
import { DataTableFilter } from '@/components/data-table-filter'

export function IssuesTable() {
  return (
    <div>
      <DataTableFilter 
        filters={filters} 
        columns={columns} 
        actions={actions} 
        strategy={strategy} 
      />
      <DataTable />
    </div>
  )
}
```

## Guides

> [!WARNING] This section is under development.

### Column Configuration

#### Column configuration

We need to describe each column in our data table. This is done using our column configuration builder.

It has a [fluent API](https://en.wikipedia.org/wiki/Fluent_interface) *(similar to Zod)* that allows us to define a column's properties in a concise, readable, and type-safe manner.

##### Using `createColumnConfigHelper()`

First, you use the `createColumnConfigHelper()` function to create a column configuration builder:

```ts
import { createColumnConfigHelper } from '@/components/data-table-filter/core/filters'
import type { Issue } from './types'

// dtf = data table filter... (sorry, couldn't resist)
const dtf = createColumnConfigHelper<Issue>()
```

Notice how we pass in our data model (`Issue`) as a generic parameter. This is required for the column configuration builder to be type safe.

##### Building a column configuration

Next, we use our helper to create a column configuration.

A column configuration begins with a call to the `text()`, `number()`, `date()`, `option()`, or `multiOption()` method of the column configuration builder.

```ts
dtf.option()
```

Now, we chain method calls to continue building our configuration, finishing off with the `build()` method:

```ts
dtf
  .option()
  .accessor((row) => row.status.id)
  .id('status')
  .displayName('Status')
  .icon(CircleDotDashedIcon)
  .build(),
```

Following this, we create an array of column configurations to use later on:

```ts
const dtf = createColumnConfigHelper<Issue>()

export const columnsConfig = [
  dtf
    .text()
    .id('title')
    .accessor((row) => row.title)
    .displayName('Title')
    .icon(Heading1Icon)
    .build(),
  dtf
    .option()
    .accessor((row) => row.status.id)
    .id('status')
    .displayName('Status')
    .icon(CircleDotDashedIcon)
    .build(),
  /* ... */
] as const
```

## Integrations

### TanStack Table

> [!WARNING] This section is under development.

### `nuqs`

> [!WARNING] This section is under development.

You can use [`nuqs`](https://nuqs.47ng.com/) to persist the filter state in the URL.

1. Install the `nuqs` and `zod` packages:

```bash
npm install nuqs zod
```

2. Use the appropriate `nuqs` adapter for your framework from the [nuqs docs](https://nuqs.47ng.com/docs/adapters).

3. Create your Zod schema for the query filter state:

```ts
import { z } from 'zod'
import type { FiltersState } from '@/components/data-table-filter/core/types'

const dataTableFilterQuerySchema = z.custom<FiltersState>()
```

## Overview

Let's take a high-level look at how we've created the data table filter component.

This will help you understand what each file contains and the general component composition.

### File structure

The data table filter component is composed of several files.

Components are placed in the `@/components` directory - all components are placed in a single file for ease of distribution:

- `data-table-filter.tsx`: The main component file.

Types, interfaces, and utilities are placed in the `@/lib` directory:

- `array.ts`: Utility functions for working with arrays.
- `filters.ts`: All TypeScript types, interfaces, and constants related to the data table filter component. Also includes the filter functions `filterFn()` for each column type.
- `table.ts`: Utility functions for working with the TanStack Table library.

### Component structure

A `PropertyFilterItem` component is composed of the following parts:

- `PropertyFilterSubject` shows the name and _(optionally)_ icon of the property being filtered on.
- `PropertyFilterOperator` shows the operator used to filter on the property.
- `PropertyFilterValue` shows the actual filter value.

<ResponsiveImage
  lightSrc='/docs/data-table-filter/property-filter-item-composition-light.png'
  darkSrc='/docs/data-table-filter/property-filter-item-composition-dark.png'
  caption='The composition of a property filter item.'
/>

The `PropertyFilterOperator` and `PropertyFilterValue` components are represented by a `Controller` which is essentially a `Popover` with an associated trigger and content.

We can break down the `PropertyFilterValueController` as an example:

- `PropertyFilterValueDisplay` is the popover **trigger**. This displays the filter value for the associated property.
- `PropertyFilterValueMenu` is the popover **content**. This renders the menu for modifying the filter value.

<ResponsiveImage
  lightSrc='/docs/data-table-filter/property-filter-value-composition-light.png'
  darkSrc='/docs/data-table-filter/property-filter-value-composition-dark.png'
  caption='The composition of a property filter value controller.'
/>

The `PropertyFilterOperatorController` has a similar composition and can be inferred from the above description and image.

## Changelog

### 2025.04.12

We've squashed a pesky bug where inferred column options would show duplicate entries in the filter menu.

We've updated the implementation of `uniq()` to use deep equality checks, instead of the previous referencial equality checks via `new Set()`.

- Issue: https://github.com/kianbazza/ui/issues/49
- PR: https://github.com/kianbazza/ui/pull/51

### 2025.04.01

> [!DANGER] This is a breaking change.

This adds support for filtering columns where the column value is not strictly a property of the original data. This was not possible before, due to the limitation of `defineMeta`'s first argument, which only accepted a direct property on the initial data type.

You can now filter columns where the value is:

- a deeply nested property (i.e. `user.name`)
- accessed using a function (i.e. `row => row.user.name.split(' ')[0]`)

To accomplish this, we've decided to change the interface for the `defineMeta` helper function. The first property is now an **accessor function**, instead of an accessor key.

See the example below for how to migrate:

```ts
type Issue = {
  status: string
  user: {
    name: string
  }
}
```

```ts {15-22}
const columns = [
  /* ... */
  columnHelper.accessor('status', {
    meta: defineMeta(
      'status', // [!code --]
      row => row.status, // [!code ++]
      { 
        type: 'option',
        icon: CircleDotDashedIcon,
        options: ISSUE_STATUSES,
      }
    ),
  }),
  columnHelper.accessor(row => row.user.name, {
    meta: defineMeta(
      row => row.user.name,
      { 
        type: 'option',
        icon: AvatarIcon,
        /* ... */
      }
    ),
  }),
]
```
